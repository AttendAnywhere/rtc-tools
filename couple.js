/* jshint node: true */
'use strict';

var debug = require('./debug')('couple');
var monitor = require('./monitor');

/**
  ## rtc/couple

  Couple a WebRTC connection with another webrtc connection via a
  signalling scope.

  ### Example Usage

  ```js
  var couple = require('rtc/couple');

  couple(new RTCConnection(), { id: 'test' }, signaller);
  ```

**/
module.exports = function(conn, targetAttr, signaller) {
  // create a monitor for the connection
  var mon = monitor(conn);
  var blockId;
  var createAnswer = createHandshaker('createAnswer');
  var createOffer = createHandshaker('createOffer');
  var openChannel;
  var queuedCandidates = [];

  function abort(err) {
    // log the error
    debug('captured error: ', err);

    // clear any block
    signaller.clearBlock(blockId);
  }

  function createHandshaker(methodName) {
    var hsDebug = require('./debug')('handshake-' + methodName);

    return function() {
      // clear the open channel
      openChannel = null;

      hsDebug('starting, making signaller request', conn.signalingState);
      signaller.request(targetAttr, function(err, channel) {
        if (err) {
          return;
        }

        hsDebug('request ok');

        // block the signalling scope
        blockId = signaller.block();

        // create the offer
        conn[methodName](
          function(desc) {
            // initialise the local description
            conn.setLocalDescription(
              desc,

              // if successful, then send the sdp over the wire
              function() {
                // save the channel as open
                openChannel = channel;

                // send the sdp
                channel.send('/sdp', desc);

                // clear the block
                signaller.clearBlock(blockId);
                hsDebug('block cleared');
              },

              // on error, abort
              abort
            );
          },

          // on error, abort
          abort
        );
      });
    }
  }

  function handleLocalCandidate(evt) {
    if (evt.candidate && openChannel) {
      openChannel.send('/candidate', evt.candidate);
    }
  }

  function handleRemoteCandidate(data) {
    if (! conn.remoteDescription) {
      return queuedCandidates.push(data);
    }
    
    debug('adding remote candidate');
    conn.addIceCandidate(new RTCIceCandidate(data));
  }

  function handleSdp(data) {
    // update the remote description
    // once successful, send the answer
    conn.setRemoteDescription(
      new RTCSessionDescription(data),
      function() {
        // apply any queued candidates
        queuedCandidates.splice(0).forEach(function(data) {
          debug('applying queued candidate');
          conn.addIceCandidate(new RTCIceCandidate(data));
        });

        // create the answer
        if (data.type === 'offer') {
          createAnswer();
        }
      },
      abort
    );
  }

  // when regotiation is needed look for the peer
  conn.addEventListener('negotiationneeded', createOffer);
  conn.addEventListener('icecandidate', handleLocalCandidate);

  // when we receive sdp, then
  signaller.on('sdp', handleSdp);
  signaller.on('candidate', handleRemoteCandidate);

  // patch in the create offer function
  mon.createOffer = createOffer;

  return mon;
};